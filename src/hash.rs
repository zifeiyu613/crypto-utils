//! Hash function implementations

use sha2::{Sha256, Sha512, Digest};
use hmac::{Hmac, Mac};
use pbkdf2::pbkdf2;
use rand::{Rng, thread_rng};

use crate::error::{CryptoError, CryptoResult};
use crate::util::{encode_base64, decode_base64};

/// Calculate SHA-256 hash of data and return it as a hex string
pub fn sha256_hex(data: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(data);
    let result = hasher.finalize();
    hex::encode(result)
}

/// Calculate SHA-512 hash of data and return it as a hex string
pub fn sha512_hex(data: &[u8]) -> String {
    let mut hasher = Sha512::new();
    hasher.update(data);
    let result = hasher.finalize();
    hex::encode(result)
}

/// Calculate HMAC-SHA256 of data with the given key
pub fn hmac_sha256(key: &[u8], data: &[u8]) -> CryptoResult<Vec<u8>> {
    type HmacSha256 = Hmac<Sha256>;

    let mut mac = HmacSha256::new_from_slice(key)
        .map_err(|_| CryptoError::InvalidKey("Invalid HMAC key".into()))?;

    mac.update(data);
    let result = mac.finalize();
    Ok(result.into_bytes().to_vec())
}

/// Calculate HMAC-SHA256 of data with the given key and return as Base64
pub fn hmac_sha256_base64(key: &[u8], data: &[u8]) -> CryptoResult<String> {
    let hmac = hmac_sha256(key, data)?;
    encode_base64(&hmac)
}

/// Password hashing with PBKDF2-HMAC-SHA256
pub struct PasswordHasher {
    iterations: u32,
    salt_length: usize,
}

impl Default for PasswordHasher {
    fn default() -> Self {
        Self {
            iterations: 100_000, // Recommended minimum as of 2023
            salt_length: 16,
        }
    }
}

impl PasswordHasher {
    /// Create a new password hasher with custom parameters
    pub fn new(iterations: u32, salt_length: usize) -> Self {
        Self {
            iterations,
            salt_length,
        }
    }

    /// Hash a password with a randomly generated salt
    ///
    /// Returns a string in the format: iterations:base64_salt:base64_hash
    pub fn hash_password(&self, password: &str) -> CryptoResult<String> {
        // Generate random salt
        let mut salt = vec![0u8; self.salt_length];
        thread_rng().fill(&mut salt[..]);

        // Hash the password
        let mut hash = [0u8; 32]; // SHA-256 output size
        pbkdf2::<Hmac<Sha256>>(
            password.as_bytes(),
            &salt,
            self.iterations,
            &mut hash
        );

        // Format the output
        let salt_b64 = encode_base64(&salt)?;
        let hash_b64 = encode_base64(&hash)?;

        Ok(format!("{}:{}:{}", self.iterations, salt_b64, hash_b64))
    }

    /// Verify a password against a hash string generated by hash_password
    pub fn verify_password(&self, password: &str, hash_string: &str) -> CryptoResult<bool> {
        // Parse the hash string
        let parts: Vec<&str> = hash_string.split(':').collect();
        if parts.len() != 3 {
            return Err(CryptoError::InvalidData("Invalid hash format".into()));
        }

        let iterations = parts[0].parse::<u32>()
            .map_err(|_| CryptoError::InvalidData("Invalid iterations".into()))?;

        let salt = decode_base64(parts[1])?;

        let hash = decode_base64(parts[2])?;

        // Compute hash with the same parameters
        let mut computed_hash = [0u8; 32];
        pbkdf2::<Hmac<Sha256>>(
            password.as_bytes(),
            &salt,
            iterations,
            &mut computed_hash
        );

        // Time-constant comparison to prevent timing attacks
        Ok(computed_hash.len() == hash.len() &&
            (0..computed_hash.len()).fold(0, |acc, i| acc | (computed_hash[i] ^ hash[i])) == 0)
    }
}
